// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

struct Sphere
{
    float yPosition;
    float speed;
    float maxY;
    float minY;
    int index;
    int3 id;
    int3 groupId;
    int3 groupIdThread;
};

float time;

RWStructuredBuffer<Sphere> spheres;
float rand(float2 co)
{
    return frac(sin(dot(co.xy ,float2(12.9898,78.233))) * 43758.5453);
}

[numthreads(32,2,1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint3 gid : SV_GROUPID, uint3 gidthread : SV_GroupThreadID)
{
    int gridDimx = 16;
    int gridDimy = 8;
    int gridDimz = 1;
    int blockDimx = 32;
    int blockDimy = 2;
    int blockDimz = 1;

    // Te√≥rico
    // int block = blockIdx.x * gridDim.y * gridDim.z + blockIdx.y * gridDim.z + blockIdx.z;
    // int thread = threadIdx.x * blockDim.y * blockDim.z + threadIdx.y * blockDim.z + threadIdx.z;
    // int ind = block * blockDim.x * blockDim.y * blockDim.z + thread;
    
    int block = gid.x * gridDimy * gridDimz + gid.y * gridDimz + gid.z;
    int thread = gidthread.x * blockDimy * blockDimz + gidthread.y * blockDimz + gidthread.z;
    int index = block * blockDimx * blockDimy * blockDimz + thread;

    for (int i = 0; i < 100000; i++)
    {
        sqrt(5000)+index/1000;
    }
    
    Sphere sphere = spheres[index];
    // Cube cube = cubes[id.x];
    sphere.index = index;
    sphere.id = id;
    sphere.groupId = gid;
    sphere.groupIdThread = gidthread;

    if(sphere.yPosition >= sphere.maxY)
    {
        // cube.speed = Random.Range(-minSpeed, -maxSpeed);
        int multiplierByThread = (thread / blockDimx) + 2; // Make the same thing for blocks-
        int multiplierByBlock = (block / gridDimx) + 2;
        sphere.speed = -rand(float2(10, 50))*((block % 64) + 1)*0.01 * multiplierByThread * multiplierByBlock;
    }
    else if(sphere.yPosition <= sphere.minY)
    {
        int multiplierByThread = (thread / blockDimx) + 2;
        int multiplierByBlock = (block / gridDimx) + 2;
        sphere.speed = rand(float2(10, 50))*((block % 64) + 1)*0.001 * multiplierByThread * multiplierByBlock;
    }

    sphere.yPosition += sphere.speed * time;
    spheres[index] = sphere;
}

